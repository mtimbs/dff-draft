"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var findBabelConfig = require('find-babel-config');

var path = require('path');

var fs = require('fs');

var checkIgnoreDepth = require('../helpers/check-ignore-depth');

var findProjectRoot = require('../helpers/find-project-root');

var getProperties = require('../helpers/get-properties');

var values = Object.values || function (obj) {
  return Object.keys(obj).map(function (e) {
    return obj[e];
  });
};

var checkPath = function checkPath(path, ext) {
  return fs.existsSync("".concat(path).concat(ext)) || fs.existsSync("".concat(path, "/index").concat(ext));
};

module.exports = {
  meta: {
    docs: {
      description: 'Warn when using relative paths to modules aliased',
      category: 'Fill me in',
      recommended: false
    },
    fixable: null,
    // or "code" or "whitespace"
    schema: [{
      type: 'object',
      properties: {
        ignoreDepth: {
          type: 'integer',
          minimum: 0
        },
        allowDepthMoreOrLessThanEquality: {
          type: 'boolean'
        },
        projectRoot: {
          type: 'string'
        },
        extensions: {
          type: 'array',
          uniqueItems: true,
          items: {
            type: 'string',
            "enum": ['.ts', '.tsx', '.jsx']
          }
        }
      },
      additionalProperties: false
    }]
  },
  create: function create(context) {
    var filename = context.getFilename();
    var filePath = path.dirname(filename); // Plugin options.

    var options = getProperties(context.options);
    var projectRootAbsolutePath = findProjectRoot(filePath, options.projectRoot); // Find alias via babel-plugin-module-resolver config.

    var alias = {};
    var babelDir = projectRootAbsolutePath || '.';

    var _findBabelConfig$sync = findBabelConfig.sync(babelDir),
        config = _findBabelConfig$sync.config;

    try {
      var validPluginNames = new Set(['babel-plugin-module-resolver', 'module-resolver']);

      var _config$plugins$filte = config.plugins.filter(function (plugins) {
        if (Array.isArray(plugins) && validPluginNames.has(plugins[0])) {
          return plugins;
        }
      }),
          _config$plugins$filte2 = _slicedToArray(_config$plugins$filte, 1),
          moduleResolver = _config$plugins$filte2[0];

      alias = moduleResolver[1].alias;
    } catch (error) {
      var message = 'Unable to find config for babel-plugin-module-resolver';
      return {
        ImportDeclaration: function ImportDeclaration(node) {
          context.report({
            node: node,
            message: message,
            loc: node.source.loc
          });
        },
        CallExpression: function CallExpression(node) {
          context.report({
            node: node,
            message: message,
            loc: node.arguments[0].loc
          });
        }
      };
    } // Build array of alias paths.


    var cwd = projectRootAbsolutePath || process.cwd();
    var aliasPaths = values(alias).map(function (a) {
      return path.join(cwd, a);
    });

    var hasError = function hasError(val) {
      if (!val) return; // template literals will have undefined val

      var ignoreDepth = options.ignoreDepth,
          projectRoot = options.projectRoot,
          extensions = options.extensions,
          allowDepthMoreOrLessThanEquality = options.allowDepthMoreOrLessThanEquality; // Ignore if directory depth matches options.

      if (checkIgnoreDepth({
        ignoreDepth: ignoreDepth,
        path: val,
        allowDepthMoreOrLessThanEquality: allowDepthMoreOrLessThanEquality
      })) return; // Error if projectRoot option specified but cannot be resolved.

      if (projectRoot && !projectRootAbsolutePath) {
        return true;
      }

      var resolvedPath = path.resolve(filePath, val);
      var resolvedExt = path.extname(val) ? '' : '.js';
      var pathExists = checkPath(resolvedPath, resolvedExt);

      if (extensions && !pathExists) {
        pathExists = extensions.filter(function (ext) {
          return checkPath(resolvedPath, ext);
        }).length;
      }

      var isAliased = aliasPaths.some(function (aliasPath) {
        return resolvedPath.includes(aliasPath);
      });
      return isAliased && pathExists && val.match(/\.\.\//); // matches, exists, and starts with ../
    };

    return {
      ImportDeclaration: function ImportDeclaration(node) {
        if (hasError(node.source.value)) {
          context.report({
            node: node,
            message: 'Do not use relative path for aliased modules',
            loc: node.source.loc
          });
        }
      },
      CallExpression: function CallExpression(node) {
        var val = node.callee.name || node.callee.type;

        if (val === 'Import' || val === 'require') {
          hasError(node.arguments[0].value) && context.report({
            node: node,
            message: 'Do not use relative path for aliased modules',
            loc: node.arguments[0].loc
          });
        }
      }
    };
  }
};